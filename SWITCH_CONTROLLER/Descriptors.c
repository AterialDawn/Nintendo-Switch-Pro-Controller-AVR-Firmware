/*
 * Nintendo Switch Pro Controller emulator firmware for AVR devices
 * Copyright (C) 2017 AterialDawn (aterial@aterialdawn.com)
 * License: GPLv3
 */

#include "Descriptors.h"

#include <LUFA/Drivers/Peripheral/Serial.h>

// HID Descriptors.
// Dumped directly via sniffing pro controller, copied from wireshark HID Report frame 79
const uint8_t PROGMEM JoystickReport[] = {
	0x05, 0x01, 0x15, 0x00, 0x09, 0x04, 0xa1, 0x01, 0x85, 0x30, 0x05, 0x01, 0x05, 0x09, 0x19, 0x01,
	0x29, 0x0a, 0x15, 0x00, 0x25, 0x01, 0x75, 0x01, 0x95, 0x0a, 0x55, 0x00, 0x65, 0x00, 0x81, 0x02,
	0x05, 0x09, 0x19, 0x0b, 0x29, 0x0e, 0x15, 0x00, 0x25, 0x01, 0x75, 0x01, 0x95, 0x04, 0x81, 0x02,
	0x75, 0x01, 0x95, 0x02, 0x81, 0x03, 0x0b, 0x01, 0x00, 0x01, 0x00, 0xa1, 0x00, 0x0b, 0x30, 0x00,
	0x01, 0x00, 0x0b, 0x31, 0x00, 0x01, 0x00, 0x0b, 0x32, 0x00, 0x01, 0x00, 0x0b, 0x35, 0x00, 0x01,
	0x00, 0x15, 0x00, 0x27, 0xff, 0xff, 0x00, 0x00, 0x75, 0x10, 0x95, 0x04, 0x81, 0x02, 0xc0, 0x0b,
	0x39, 0x00, 0x01, 0x00, 0x15, 0x00, 0x25, 0x07, 0x35, 0x00, 0x46, 0x3b, 0x01, 0x65, 0x14, 0x75,
	0x04, 0x95, 0x01, 0x81, 0x02, 0x05, 0x09, 0x19, 0x0f, 0x29, 0x12, 0x15, 0x00, 0x25, 0x01, 0x75,
	0x01, 0x95, 0x04, 0x81, 0x02, 0x75, 0x08, 0x95, 0x34, 0x81, 0x03, 0x06, 0x00, 0xff, 0x85, 0x21,
	0x09, 0x01, 0x75, 0x08, 0x95, 0x3f, 0x81, 0x03, 0x85, 0x81, 0x09, 0x02, 0x75, 0x08, 0x95, 0x3f,
	0x81, 0x03, 0x85, 0x01, 0x09, 0x03, 0x75, 0x08, 0x95, 0x3f, 0x91, 0x83, 0x85, 0x10, 0x09, 0x04,
	0x75, 0x08, 0x95, 0x3f, 0x91, 0x83, 0x85, 0x80, 0x09, 0x05, 0x75, 0x08, 0x95, 0x3f, 0x91, 0x83,
	0x85, 0x82, 0x09, 0x06, 0x75, 0x08, 0x95, 0x3f, 0x91, 0x83, 0xc0
};

const uint8_t PROGMEM HidReportDescriptor[] = 
{
	0x05, 0x01, 0x15, 0x00, 0x09, 0x04, 0xa1, 0x01, 0x85, 0x30, 0x05, 0x01, 0x05, 0x09, 0x19, 0x01,
	0x29, 0x0a, 0x15, 0x00, 0x25, 0x01, 0x75, 0x01, 0x95, 0x0a, 0x55, 0x00, 0x65, 0x00, 0x81, 0x02,
	0x05, 0x09, 0x19, 0x0b, 0x29, 0x0e, 0x15, 0x00, 0x25, 0x01, 0x75, 0x01, 0x95, 0x04, 0x81, 0x02,
	0x75, 0x01, 0x95, 0x02, 0x81, 0x03, 0x0b, 0x01, 0x00, 0x01, 0x00, 0xa1, 0x00, 0x0b, 0x30, 0x00,
	0x01, 0x00, 0x0b, 0x31, 0x00, 0x01, 0x00, 0x0b, 0x32, 0x00, 0x01, 0x00, 0x0b, 0x35, 0x00, 0x01,
	0x00, 0x15, 0x00, 0x27, 0xff, 0xff, 0x00, 0x00, 0x75, 0x10, 0x95, 0x04, 0x81, 0x02, 0xc0, 0x0b,
	0x39, 0x00, 0x01, 0x00, 0x15, 0x00, 0x25, 0x07, 0x35, 0x00, 0x46, 0x3b, 0x01, 0x65, 0x14, 0x75,
	0x04, 0x95, 0x01, 0x81, 0x02, 0x05, 0x09, 0x19, 0x0f, 0x29, 0x12, 0x15, 0x00, 0x25, 0x01, 0x75,
	0x01, 0x95, 0x04, 0x81, 0x02, 0x75, 0x08, 0x95, 0x34, 0x81, 0x03, 0x06, 0x00, 0xff, 0x85, 0x21,
	0x09, 0x01, 0x75, 0x08, 0x95, 0x3f, 0x81, 0x03, 0x85, 0x81, 0x09, 0x02, 0x75, 0x08, 0x95, 0x3f,
	0x81, 0x03, 0x85, 0x01, 0x09, 0x03, 0x75, 0x08, 0x95, 0x3f, 0x91, 0x83, 0x85, 0x10, 0x09, 0x04,
	0x75, 0x08, 0x95, 0x3f, 0x91, 0x83, 0x85, 0x80, 0x09, 0x05, 0x75, 0x08, 0x95, 0x3f, 0x91, 0x83,
	0x85, 0x82, 0x09, 0x06, 0x75, 0x08, 0x95, 0x3f, 0x91, 0x83, 0xc0
};

const uint8_t PROGMEM DeviceDescriptor[] = 
{
	0x12, 0x01, 0x00, 0x02, 0x00, 0x00, 0x00, 0x40, 0x7e, 0x05, 0x09, 0x20, 0x00, 0x02, 0x01, 0x02,
	0x03, 0x01
};

const uint8_t PROGMEM ShortConfigData[] = {
	0x09, 0x02, 0x29, 0x00, 0x01, 0x01, 0x00, 0xa0, 0xfa
};

const uint8_t PROGMEM ConfigurationData[] = 
{
	0x09, 0x02, 0x29, 0x00, 0x01, 0x01, 0x00, 0xa0, 0xfa, 0x09, 0x04, 0x00, 0x00, 0x02, 0x03, 0x00,
	0x00, 0x00, 0x09, 0x21, 0x11, 0x01, 0x00, 0x01, 0x22, 0xcb, 0x00, 0x07, 0x05, 0x81, 0x03, 0x40,
	0x00, 0x08, 0x07, 0x05, 0x02, 0x03, 0x40, 0x00, 0x08
};

// Language Descriptor Structure
const USB_Descriptor_String_t PROGMEM LanguageString = USB_STRING_DESCRIPTOR_ARRAY(LANGUAGE_ID_ENG);

// Manufacturer and Product Descriptor Strings
const USB_Descriptor_String_t PROGMEM ManufacturerString = USB_STRING_DESCRIPTOR(L"Nintendo Co., Ltd.");
const USB_Descriptor_String_t PROGMEM ProductString      = USB_STRING_DESCRIPTOR(L"Pro Controller");
const USB_Descriptor_String_t PROGMEM SerialString		 = USB_STRING_DESCRIPTOR(L"000000000001");

// USB Device Callback - Get Descriptor
uint16_t CALLBACK_USB_GetDescriptor(
const uint16_t wValue,
const uint16_t wIndex,
const void** const DescriptorAddress
) {
	const uint8_t  DescriptorType   = (wValue >> 8);
	const uint8_t  DescriptorNumber = (wValue & 0xFF);

	const void* Address = NULL;
	uint16_t    Size    = NO_DESCRIPTOR;

	switch (DescriptorType)
	{
		case DTYPE_Device:
		Address = &DeviceDescriptor;
		Size    = sizeof(DeviceDescriptor);
		break;
		case DTYPE_Configuration:
		if(USB_ControlRequest.wLength == 9)
		{
			Address = &ShortConfigData;
			Size    = sizeof(ShortConfigData);
		}
		else
		{
			Address = &ConfigurationData;
			Size    = sizeof(ConfigurationData);
		}
		break;
		case DTYPE_String:
		switch (DescriptorNumber)
		{
			case STRING_ID_Language:
			Address = &LanguageString;
			Size    = pgm_read_byte(&LanguageString.Header.Size);
			break;
			case STRING_ID_Manufacturer:
			Address = &ManufacturerString;
			Size    = pgm_read_byte(&ManufacturerString.Header.Size);
			break;
			case STRING_ID_Product:
			Address = &ProductString;
			Size    = pgm_read_byte(&ProductString.Header.Size);
			break;
			case STRING_ID_SerialNumber:
			Address = &SerialString;
			Size	= pgm_read_byte(&SerialString.Header.Size);
			break;
		}

		break;
		case DTYPE_HID:
		Address = &JoystickReport;
		Size    = sizeof(JoystickReport);
		break;
		case DTYPE_Report:
		Address = &HidReportDescriptor;
		Size    = sizeof(HidReportDescriptor);
		break;
	}

	*DescriptorAddress = Address;
	return Size;
}